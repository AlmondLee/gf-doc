
[TOC]

>[danger] # 方法列表

用户可以通过路由控制来自定义URI与注册服务的关联关系，gf的路由控制规则依靠正则表达式来实现，相对来说比较专业，灵活度比较高。路由解析/打包(Dispatch/Patch)由Web Server自动调用，用户只需调用路由规则注册/删除方法(Set*/Remove*)完成注册即可。
```go
func (r *Router) Dispatch(uri string) (string, error)
func (r *Router) Patch(content []byte) ([]byte, error)
func (r *Router) RemovePatchRule(rule string)
func (r *Router) RemoveRule(rule string)
func (r *Router) SetPatchRule(rule, replace string)
func (r *Router) SetRule(rule, replace string)
```
>[danger] # Dispatch

我们来看一个路由注册解析的简单例子：

gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/router.go

```go
package demo

import "gitee.com/johng/gf/g/net/ghttp"

func init() {
    ghttp.GetServer().BindHandler("/list", List)
    ghttp.GetServer().Router.SetRule(`\/list\/page\/(\d+)[\/\?]*`, "/list?page=$1&")
}

func List(r *ghttp.Request) {
    r.Response.Write("list page:" + r.GetQueryString("page"))
}
```
这是一个简单的示例，用以将列表分页伪静态的链接转换为正常的GET参数链接，并让控制器能够通过GET方式获取到page参数(当然这只是为了演示方便，实际项目中不会这样单独处理某一个页面的伪静态)。

1. 首先向Web Server注册了一个回调函数，注册URI是“/list”；
2. 随后设定对URI的路由解析规则，设定匹配的URI正则表达式，以及匹配后的替换格式；
3. 启动main.go，手动打开浏览器访问URL：http://127.0.0.1:8199/list/page/2 ；
4. Web Server识别到URI "/list/page2"有对应的路由解析规则，因此将该URI解析为 "/list?page=2"，并寻址"/list"对应的服务注册信息，将请求处理转交给服务注册函数进行处理；
5. 通过r.GetQueryString可以获取到GET参数中传递的page参数；
6. 最终可以看到页面输出了“list page:2”，表示路由规则已经生效；

路由规则解析是有优先级的，根据调用Router.SetRule注册路由规则的先后顺序进行解析，因此，在项目中使用的时候，建议统一在一个地方进行路由注册管理，以便维护和控制路由注册优先级。

此外，在Web Server中路由解析优先级是高于任何的服务注册功能的，我们将上面的示例稍微做下调整：

gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/router2.go

```go
package demo

import "gitee.com/johng/gf/g/net/ghttp"

func init() {
    ghttp.GetServer().BindHandler("/list",        List)
    ghttp.GetServer().BindHandler("/list/page/2", List2)
    ghttp.GetServer().Router.SetRule(`\/list\/page\/(\d+)[\/\?]*`, "/list?page=$1&")
}

func List1(r *ghttp.Request) {
    r.Response.Write("list page:" + r.GetQueryString("page"))
}

func List2(r *ghttp.Request) {
    r.Response.Write("customed list page")
}
```
这是一个特殊的例子，为了演示路由控制对服务注册的优先级影响，我们将URI "/list/page/2" 进行了一个单独的服务注册，并由List2函数进行处理。但是当再次访问 http://127.0.0.1:8199/list/page/2 时，会发现List2函数根本就没有执行，Web Server还是将请求被转交给了List1回调函数处理。因为路由控制已经优先地将URI解析为了 "/list?page=2"，那么Web Server服务寻址的时候，也便寻址到了List1。



>[danger] # Patch

可以看到Router的方法中还存在Patch相关的方法，这些方法是路由控制提供的与“路由解析”相对应的“路由打包”方法，会将给定的内容按照路由打包规则进行正则替换，并返回给客户端。Web Server在输出内容给客户端时，会检测是否存在路由打包规则，如果存在的话会先对输出内容进行“打包”处理，随后输出内容到客户端。“路由打包”常用于对输出内容进行统一的伪静态链接转换处理，而避免了分别对单独的链接进行转换或者函数调用处理的繁琐。

我们来看一个路由注册打包的简单例子：

gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/router-patch.go

```go
package demo

import "gitee.com/johng/gf/g/net/ghttp"

func init() {
    ghttp.GetServer().BindHandler("/router-patch", RouterPatch)
    ghttp.GetServer().Router.SetPatchRule(`\/list\?page=(\d+)&*`, "/list/page/$1?")
}

func RouterPatch(r *ghttp.Request) {
    r.Response.Write(`<a href="/list?page=2&ajax=1">page2</a>`)
}
```

执行main.go，访问：http://127.0.0.1:8199/router-patch ，页面输出结果为：
```html
<a href="/list/page/2?ajax=1">page2</a>
```

可以看到，动态的a链接“/list?page=2&ajax=1”已经被自动打包成了伪静态链接“/list/page/2?ajax=1”。


