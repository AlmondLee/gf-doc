用户可以路由控制来自定义URI与注册服务的关联关系，gf的路由控制规则依靠正则表达式来实现，相对来说比较专业，灵活度比较高，但是另一方面，缺点是配置起来可能不是那么方便(针对正则表达式不熟悉的同学)。路由控制是由Web Server自动调用的(Dispatch/Patch)，用户只需调用路由规则注册/删除方法(Set*/Remove*)完成注册即可.

    func (r *Router) Dispatch(uri string) (string, error)
    func (r *Router) Patch(content []byte) ([]byte, error)
    func (r *Router) RemovePatchRule(rule string)
    func (r *Router) RemoveRule(rule string)
    func (r *Router) SetPatchRule(rule, replace string)
    func (r *Router) SetRule(rule, replace string)

我们来看一个简单示例：
gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/router.go
```go
package demo

import "gitee.com/johng/gf/g/net/ghttp"

func init() {
    ghttp.GetServer().BindHandler("/list", List)
    ghttp.GetServer().Router.SetRule(`\/list\/page\/(\d+)[\/\?]*`, "/list?page=$1&")
}

func List(r *ghttp.Request) {
    r.Response.WriteString("list page:" + r.GetQueryString("page"))
}
```
1. 首先向Web Server注册了一个回调函数，注册URI是“/list”；
2. 随后设定对URI的路由解析规则，设定匹配的URI正则表达式，以及匹配后的替换格式；
3. 启动main.go，访问：http://127.0.0.1:8199/list/page/2 ，可以看到页面输出了“list page:2”，表示路由规则已经生效；

路由规则解析是有优先级的，根据调用Router.SetRule注册路由规则的先后顺序进行解析，因此，在项目中使用的时候，建议统一在一个地方进行路由注册管理。


可以看到Router的方法中存在Patch相关的方法，这些方法是路由控制提供的与“路由解析”相对应的“路由打包方法”，会将给定的内容按照路由打包规则进行正则替换，并返回给客户端。