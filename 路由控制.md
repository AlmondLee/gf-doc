
[TOC]

gf框架自建了非常强大的路由控制功能，提供了比任何同类框架更加出色的路由特性，支持流行的命名匹配规则、模糊匹配规则及字段匹配规则，并提供了优秀的优先级管理机制。

>[danger] # 一个简单示例

在真正开启本章的核心内容之前，我们先来看一个简单的动态路由使用示例：
```go
package main

import (
    "gitee.com/johng/gf/g/net/ghttp"
    "gitee.com/johng/gf/g"
)

func main() {
    s := g.Server()
    s.BindHandler("/:name", func(r *ghttp.Request){
       r.Response.Writeln(r.Router.Uri)
    })
    s.BindHandler("/:name/update", func(r *ghttp.Request){
        r.Response.Writeln(r.Router.Uri)
    })
    s.BindHandler("/:name/:action", func(r *ghttp.Request){
        r.Response.Writeln(r.Router.Uri)
    })
    s.BindHandler("/:name/*any", func(r *ghttp.Request){
       r.Response.Writeln(r.Router.Uri)
    })
    s.BindHandler("/user/list/{field}.html", func(r *ghttp.Request){
        r.Response.Writeln(r.Router.Uri)
    })
    s.SetPort(8199)
    s.Run()
}
```
以上示例中展示了gf框架支持的三种模糊匹配路由规则，```:name```、```*any```、```{field}```分别表示命名匹配规则、模糊匹配规则及字段匹配规则。不同的规则中使用```/```符号来划分层级，层级越深的规则优先级也越高，gf框架的底层路由存储使用的是```哈希表```与```数据链表```构成的```路由树```。我们运行以上示例，通过访问几个URL来看看效果：
```html
                  URL                               结果
http://127.0.0.1:8199/user/list/2.html      /user/list/{field}.html
http://127.0.0.1:8199/user/update           /:name/update
http://127.0.0.1:8199/user/info             /:name/:action
http://127.0.0.1:8199/user                  /:name/*any
```
在这个示例中我们也可以看到，由于优先级的限制，路由规则```/:name```会被```/:name/*any```规则覆盖，将会无法被匹配到，所以在分配路由规则的时候，需要进行统一l规划和管理，避免类似情况的产生。


>[danger] #  路由注册规则

>[success] ## 路由注册参数

我们来看一下之前一直使用的```BindHandler```的原型：
```go
func (s *Server) BindHandler(pattern string, handler HandlerFunc) error
```
该方法是服务注册的最基础方法，其中的```pattern```为路由注册规则字符串，在其他服务注册方法中也会使用到，参数格式如下：
```
[HTTPMethod:]路由规则[@域名]
```
其中HTTPMethod（支持的Method：```GET,PUT,POST,DELETE,PATCH,HEAD,CONNECT,OPTIONS,TRACE```）和域名为非必需参数，一般来说直接给定路由规则参数即可，```BindHandler```会自动绑定所有的请求方式，如果给定```HTTPMethod```，那么路由规则仅会在该请求方式下有效。```@域名```可以指定生效的域名名称，那么该路由规则仅会在该域名下生效。我们来看一个例子：
```go
package main

import (
    "gitee.com/johng/gf/g/net/ghttp"
    "gitee.com/johng/gf/g"
)

func main() {
    s := g.Server()
    // 该路由规则仅会在GET请求下有效
    s.BindHandler("GET:/{table}/list/{page}.html", func(r *ghttp.Request){
        r.Response.WriteJson(r.Router)
    })
    // 该路由规则仅会在GET请求及localhost域名下有效
    s.BindHandler("GET:/order/info/{order_id}@localhost", func(r *ghttp.Request){
        r.Response.WriteJson(r.Router)
    })
    // 该路由规则仅会在DELETE请求下有效
    s.BindHandler("DELETE:/comment/{id}", func(r *ghttp.Request){
        r.Response.WriteJson(r.Router)
    })
    s.SetPort(8199)
    s.Run()
}
```
其中返回的参数```r.Router```是当前匹配的路由规则信息，访问当该方法的时候，服务端会输出当前匹配的路由规则信息。执行后，我们在终端使用```curl```命令进行测试：
```shell
john@johnhome:~$ curl -XGET http://127.0.0.1:8199/order/list/1.html
{"Domain":"default","Method":"GET","Priority":3,"Uri":"/{table}/list/{page}.html"}

john@johnhome:~$ curl -XGET http://127.0.0.1:8199/order/info/1
Not Found

john@johnhome:~$ curl -XGET http://localhost:8199/order/info/1
{"Domain":"localhost","Method":"GET","Priority":3,"Uri":"/order/info/{order_id}"}

john@johnhome:~$ curl -XDELETE http://127.0.0.1:8199/comment/1000
{"Domain":"default","Method":"DELETE","Priority":2,"Uri":"/comment/{id}"}

john@johnhome:~$ curl -XGET http://127.0.0.1:8199/comment/1000
Not Found
```



>[success] ## 静态路由规则

路由规则分为两种：**静态路由规则** 和 **动态路由规则**。


静态路由规则是指不带任何命名匹配和模糊匹配的路由规则，即是一个确定的URI地址，例如：```/user/info```，```/src/path/file```，```/member/register```等等。**静态路由规则在服务注册及服务检索的时候效率非常高**，因为不需要做额外的优先级和正则规则判断，底层的数据结构仅仅是一张哈希表，注册和检索的时间复杂度都为O(1)。因此，在实际项目开发中，建议能够使用静态路由规则的地方尽量使用静态路由规则。


>[success] ## 动态路由规则

动态路由规则分为两种：**命名匹配规则**和**模糊匹配规则**。动态路由的底层数据结构由树形哈希表和叶子节点的链表构成，树形哈希表便于高效率地层级匹配URI；叶子节点的链表用于优先级控制，同一层级的路由规则按照优先级进行排序，优先级高的规则排在链表头。底层的路由规则与请求URI的匹配计算采用的是正则表达式，并充分使用了缓存机制，执行效率十分高效。

### 命名匹配规则

使用```:name```方式进行匹配(```name```为自定义的匹配名称)，对URI指定层级的参数进行命名匹配（类似正则```([\w\.\-]+)```，该URI层级必须有值），对应匹配参数会被解析为GET参数并传递给注册的服务使用。

匹配示例1：
```shell
rule: /user/:user

/user/john                match
/user/you                 match
/user/john/profile        no match
/user/                    no match
```
匹配示例2：
```shell
rule: /:name/action

/john/name                no match
/john/action              match
/smith/info               no match
/smith/info/age           no match
/smith/action             match
```
匹配示例3：
```shell
rule: /:name/:action

/john/name                match
/john/info                match
/smith/info               match
/smith/info/age           no match
/smith/action/del         no match
```

### 模糊匹配规则

使用```*any```方式进行匹配(```any```为自定义的匹配名称)，对URI指定位置之后的参数进行模糊匹配（类似正则```(.*)```，该URI层级可以为空），并将匹配参数解析为GET参数并传递给注册的服务使用。

匹配示例1：
```shell
rule: /src/*path

/src/                     match
/src/somefile.go          match
/src/subdir/somefile.go   match
/user/                    no match
/user/john                no match
```
匹配示例2：
```shell
rule: /src/*path/:action

/src/                     no match
/src/somefile.go          match
/src/somefile.go/del      match
/src/subdir/file.go/del   match
```
匹配示例3：
```shell
rule: /src/*path/show

/src/                     no match
/src/somefile.go          no match
/src/somefile.go/del      no match
/src/somefile.go/show     match
/src/subdir/file.go/show  match
/src/show                 match
```

>[danger] # 路由优先级控制

优先级控制最主要的两点因素：

1. **层级越深的规则优先级越高**；
2. **命名匹配比模糊匹配优先级高**；

我们来看示例（左边的规则优先级比右边高）：
```shell
/:name                   >            /*any
/user/name               >            /user/:action
/:name/info              >            /:name/:action
/:name/:action           >            /:name/*action
/src/path/del            >            /src/path
/src/path/del            >            /src/path/:action
/src/path/*any           >            /src/path
```

本章节开头的示例中已经能够很好的说明优先级控制，这里便不再举例。

>[danger] # 路由检索算法介绍

路由检索概述：
1. 路由进行匹配检索的时候将会从根部开始通过哈希表一层一层往叶子节点进行匹配；
2. 每一个节点中如果有数据链表，那么保存该链表到一个链表数组中，以便后续回溯；
3. 当检索到达叶子后再将匹配到的数据链表按照从叶子节点往根部节点进行回溯检索；
4. 直到匹配到满足条件的路由规则为止。