
[TOC]

gf框架提供了自建的非常强大的路由控制功能，支持流行的命名匹配规则及模糊匹配规则，并提供了优秀的优先级管理机制。以下是一个服务注册中使用路由控制的示例：
```go
package main

import "gitee.com/johng/gf/g/net/ghttp"

func main() {
    s := ghttp.GetServer()
    s.BindHandler("/:name", func(r *ghttp.Request){
    	r.Response.Writeln("pattern: /:name match")
        r.Response.Writeln(r.Get("name"))
    })
    s.BindHandler("/:name/:action", func(r *ghttp.Request){
        r.Response.Writeln("pattern: /:name/:action match")
        r.Response.Writeln(r.Get("name"))
        r.Response.Writeln(r.Get("action"))
    })
    s.BindHandler("/:name/*any", func(r *ghttp.Request){
        r.Response.Writeln("pattern: /:name/*any match")
        r.Response.Writeln(r.Get("name"))
        r.Response.Writeln(r.Get("any"))
    })
    s.SetPort(8199)
    s.Run()
}
```
其中，```/:name/:action```的路由规则优先级比```/:name/*any```高，因此当访问 ```http://127.0.0.1:8199/john/info```时，得到的结果是：
```
pattern: /:name/:action match
john
info
```



路由规则分为两种：**静态路由规则**和**动态路由规则**。

>[success] ## 静态路由规则

静态路由规则是指不带任何命名匹配和模糊匹配的路由规则，即是一个确定的URI地址，例如：```/user/info```，```/src/path/file```，```/member/register```等等。**静态路由规则在服务注册及服务检索的时候效率非常高**，因为不需要做额外的优先级和正则规则判断，底层的数据结构仅仅是一张哈希表，注册和检索的时间复杂度都为O(1)。因此，在实际项目开发中，建议能够使用静态路由规则的地方尽量使用静态路由规则。


>[success] ## 动态路由规则

动态路由规则分为两种：**命名匹配规则**和**模糊匹配规则**。动态路由的底层数据结构由树形哈希表和叶子节点的链表构成，树形哈希表便于高效率地层级匹配URI；叶子节点的链表用于优先级控制，同一层级的路由规则按照优先级进行排序，优先级高的规则排在链表头。底层的路由规则与请求URI的匹配计算采用的是正则表达式，并充分使用了缓存机制，执行效率十分高效。

### 命名匹配规则

使用```:name```方式进行匹配(```name```为自定义的匹配名称)，匹配成功后对应匹配参数会被解析为GET参数并传递给注册的服务使用。

匹配示例1：
```shell
rule: /user/:user

/user/john                match
/user/you                 match
/user/john/profile        no match
/user/                    no match
```
匹配示例2：
```shell
rule: /:name/action

/john/name                no match
/john/action              match
/smith/info               no match
/smith/info/age           no match
/smith/action             match
```
匹配示例3：
```shell
rule: /:name/:action

/john/name                match
/john/info                match
/smith/info               match
/smith/info/age           no match
/smith/action/del         no match
```

### 模糊匹配规则

使用```*any```方式进行匹配(```any```为自定义的匹配名称)，一般常用语末尾匹配，将会匹配URI随后所有的参数，并将匹配参数解析为GET参数并传递给注册的服务使用。

匹配示例1：
```shell
rule: /src/*path

/src/                     match
/src/somefile.go          match
/src/subdir/somefile.go   match
/user/                    no match
/user/john                no match
```
匹配示例2：
```shell
rule: /src/*path/:action

/src/                     no match
/src/somefile.go          no match
/src/somefile.go/del      match
/src/subdir/file.go/del   match
```
匹配示例3：
```shell
rule: /src/*path/show

/src/                     no match
/src/somefile.go          no match
/src/somefile.go/del      no match
/src/somefile.go/show     match
/src/subdir/file.go/show  match
```

>[success] ## 路由优先级控制

优先级控制最主要的两点因素：

1. **层级越深的规则优先级越高**；
2. **命名匹配比模糊匹配优先级高**；

我们来看示例（左边的规则优先级比右边高）：
```shell
/:name                   >            /*any
/user/name               >            /user/:action
/:name/info              >            /:name/:action
/:name/:action           >            /:name/*action
/src/path/del            >            /src/path
/src/path/del            >            /src/path/:action
/src/path/*any           >            /src/path
```

本章节开头的示例中已经能够很好的说明优先级控制，这里便不再举例。

此外，需要说明的是，静态匹配规则```/```是比较特殊的一个规则，优先级最低，当任何其他规则无法匹配时，会自动匹配到该规则下面，可以把它看做一个全局规则。例如，当系统有三条路由规则```/```、```/user```、```/:name```，当应用端请求```/user/register```时，将会被路由规则```/```捕获；当应用端请求```/user```时，将会被路由规则```/user```捕获；当应用端请求```/src```时，将会被路由规则```/:name```捕获。