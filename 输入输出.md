
[TOC]

>[danger] # 请求输入

请求输入依靠 ghttp.Request 对象实现：
```go
type Request struct {
    http.Request
    getvals  *url.Values     // GET参数
    Id       int             // 请求id(唯一)
    Server   *Server         // 请求关联的服务器对象
    Cookie   *Cookie         // 与当前请求绑定的Cookie对象(并发安全)
    Session  *Session        // 与当前请求绑定的Session对象(并发安全)
    Response *Response       // 对应请求的返回数据操作对象
}
```
ghttp.Request继承了底层的http.Request对象，并且包含了会话相关的Cookie和Session对象(每个请求都会有两个独立的Cookie和Session对象)。此外，每个请求有一个唯一的Id（请求Id，全局唯一），用以标识每一个请求。此外，成员对象包含一个与当前请求对应的返回输出对象指针Response，用于数据的返回。

相关方法（API详见[godoc](https://godoc.org/github.com/johng-cn/gf/g/net/ghttp)）：
```go
func (r *Request) GetJson() *gjson.Json
func (r *Request) GetPost(k string) []string
func (r *Request) GetPostArray(k string) []string
func (r *Request) GetPostBool(k string) bool
func (r *Request) GetPostFloat32(k string) float32
func (r *Request) GetPostFloat64(k string) float64
func (r *Request) GetPostInt(k string) int
func (r *Request) GetPostMap(defaultMap map[string]string) map[string]string
func (r *Request) GetPostString(k string) string
func (r *Request) GetPostUint(k string) uint
func (r *Request) GetQuery(k string) []string
func (r *Request) GetQueryArray(k string) []string
func (r *Request) GetQueryBool(k string) bool
func (r *Request) GetQueryFloat32(k string) float32
func (r *Request) GetQueryFloat64(k string) float64
func (r *Request) GetQueryInt(k string) int
func (r *Request) GetQueryMap(defaultMap map[string]string) map[string]string
func (r *Request) GetQueryString(k string) string
func (r *Request) GetQueryUint(k string) uint
func (r *Request) GetRaw() []byte
func (r *Request) GetRequest(k string) []string
func (r *Request) GetRequestArray(k string) []string
func (r *Request) GetRequestBool(k string) bool
func (r *Request) GetRequestFloat32(k string) float32
func (r *Request) GetRequestFloat64(k string) float64
func (r *Request) GetRequestInt(k string) int
func (r *Request) GetRequestMap(defaultMap map[string]string) map[string]string
func (r *Request) GetRequestString(k string) string
func (r *Request) GetRequestUint(k string) uint
```
以上方法可以分为以下几类：
1. **GetQuery\***: 获取GET方式传递过来的参数；
2. **GetPost\***: 获取POST方式传递过来的参数；
3. **GetRequest\***: 优先查找GET参数中是否有指定键名的参数，如果没有的话返回POST参数中指定键名的参数；
4. **GetRaw**: 获取原始的客户端提交数据(二进制[ ]byte类型)，与HTTP Method无关(注意由于是读取的请求缓冲区数据，该方法执行一次之后缓冲区便会被清空)；
5. **GetJson**: 自动将原始请求信息解析为gjson.Json对象返回，gjson.Json对象具体在JSON模块章节中介绍；

其中，获取的参数方法可以对指定键名的数据进行自动类型转换，例如：http://127.0.0.1:8199/?amount=19.66 ，通过GetQueryString将会返回19.66的字符串类型，GetQueryFloat32/GetQueryFloat64将会分别返回float32和float64类型的数值19.66。**但是，GetQueryInt/GetQueryUint将会返回0，而不会返回19或者20，数值的处理交给业务逻辑本身来执行**。

>[danger] # 请求输出

数据输出对象定义如下：
```go
type Response struct {
    http.ResponseWriter
    bufmu  sync.RWMutex // 缓冲区互斥锁
    buffer []byte       // 每个请求的返回数据缓冲区
}
```
可以看到ghttp.Response对象继承了标准库的http.ResponseWriter对象，因此完全可以使用标准库的方法来进行输出控制。

当然，建议使用ghttp.Response封装的方法来控制输出，ghttp.Response的数据输出使用Write\*相关方法实现，并且数据输出采用了Buffer机制，数据的处理效率比较高，任何时候可以通过OutputBuffer方法输出缓冲区数据到客户端，并清空缓冲区数据。
```go
func (r *Response) Buffer() []byte
func (r *Response) ClearBuffer()
func (r *Response) OutputBuffer()
func (r *Response) Write(content []byte)
func (r *Response) WriteString(content string)
```
此外，需要提一下，Header的操作可以通过标准库的方法来实现，例如：
```go
r.Header().Set("Content-Type", "text/plain; charset=utf-8")
```


>[danger] # 文件上传

文件上传的功能比较常用，我们来看一个使用gf框架的Web Server服务端处理文件上传的例子：

https://gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/upload.go

```go
package demo

import (
    "gitee.com/johng/gf/g/os/gfile"
    "gitee.com/johng/gf/g/net/ghttp"
)

func Upload(r *ghttp.Request) {
    if f, h, e := r.FormFile("upload-file"); e == nil {
        defer f.Close()
        fname  := gfile.Basename(h.Filename)
        buffer := make([]byte, h.Size)
        f.Read(buffer)
        gfile.PutBinContents("/tmp/" + fname, buffer)
        r.Response.WriteString(fname + " uploaded successly"))
    } else {
        r.Response.WriteString(e.Error())
    }
}

func UploadShow(r *ghttp.Request) {
    r.Response.WriteString(`
<html>
<head>
    <title>上传文件</title>
</head>
    <body>
        <form enctype="multipart/form-data" action="/upload" method="post">
            <input type="file" name="upload-file" />
            <input type="submit" value="upload" />
        </form>
    </body>
</html>
`)
}

func init() {
    ghttp.GetServer().BindHandler("/upload",      Upload)
    ghttp.GetServer().BindHandler("/upload/show", UploadShow)
}
```

访问 http://127.0.0.1:8199/upload/show 选择需要上传的文件，提交之后可以看到文件上传成功到服务器上。

文件上传比较简单，**但是需要注意的是，服务端在上传处理中需要使用f.Close() 关闭掉临时上传文件指针**。


>[danger] # HTTP客户端

gf除了提供了强大的服务端处理功能，还提供了强大易用的HTTP客户端功能，具体请查看模块设计中的 [HTTP客户端](HTTP客户端.md) 章节。