
[TOC]


在Web开发中，模板引擎是最核心的组件之一，是连接控制器与视图层的桥梁。Go标准库的text/template包已经提供了非常强大的模板引擎功能，gf框架的模板引擎以此为基础，并在易用性、功能性、数据隔离性方面做了一定封装和改进，提供了gview包。此外，在内置的MVC开发模式中，每一个控制器注册的对象中都会有一个gmvc.View成员对象，用于不同请求的模板渲染处理。本章节首先介绍了gf框架在两种服务注册模式下的模板引擎使用，其次再介绍标准库基本语法和基本函数的使用。


>[danger] # 使用方法

>[success] ## 控制器视图

gf为控制器提供了良好的模板引擎支持，由gmvc.View视图对象进行管理，提供了良好的数据隔离性。控制器视图是并发安全设计的，允许在多线程中异步操作。
```go
func (view *View) Assign(key string, value interface{})
func (view *View) Assigns(data map[string]interface{})
func (view *View) Display(files ...string) error
func (view *View) Parse(file string) ([]byte, error)
```
使用示例：

gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/template.go

```go
package demo

import (
    "gitee.com/johng/gf/g/net/ghttp"
    "gitee.com/johng/gf/g/frame/gmvc"
)

type ControllerTemplate struct {
    gmvc.Controller
}

func init() {
    ghttp.GetServer().BindControllerMethod("/template", &ControllerTemplate{}, "Info")
}

func (c *ControllerTemplate) Info() {
    c.View.Assign("name", "john")
    c.View.Assigns(map[string]interface{}{
        "age"   : 18,
        "score" : 100,
    })
    c.View.Display("user/index.tpl")
}
```
其中，给定的模板文件file参数是需要带完整的文件名后缀，例如：index.tpl，index.html等等，模板引擎对模板文件后缀名没有要求，用户可完全自定义。此外，模板文件参数也支持文件的绝对路径(完整的文件路径)。

>[success] ## 非控制器视图

非控制器中使用模板引擎没有控制器视图的支持，可以使用底层的gview包来实现，可以通过单例管理器来获取默认的单例gview对象。

gview包方法列表：
```go
func Get(path string) *View
func New(path string) *View
func (view *View) BindFunc(name string, function interface{})
func (view *View) GetPath() string
func (view *View) GetTplContent() string
func (view *View) Parse(file string, params map[string]interface{}) ([]byte, error)
func (view *View) SetPath(path string)
```
使用示例：

gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/template2.go

```go
package demo

import (
    "gitee.com/johng/gf/g/net/ghttp"
    "gitee.com/johng/gf/g/frame/gins"
)

func init() {
    ghttp.GetServer().BindHandler("/template2", func(r *ghttp.Request){
        content, _ := gins.View().Parse("index.tpl", map[string]interface{}{
            "id"   : 123,
            "name" : "john",
        })
        r.Response.Write(content)
    })
}
```
在这个示例中我们使用单例管理器获取一个默认的视图对象，随后通过该视图渲染对应模板目录下的index.tpl模板文件并给定模板变量参数。

我们也可以通过SetPath方法中心指定视图对象的模板目录，该方法是并发安全的，但是需要注意一旦改变了该视图对象的模板目录，将会在整个进程中生效。

使用示例：

gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/template3.go

```go
package demo

import (
    "gitee.com/johng/gf/g/net/ghttp"
    "gitee.com/johng/gf/g/frame/gins"
)

func init() {
    gins.View().SetPath("/home/www/template/")
    ghttp.GetServer().BindHandler("/template3", func(r *ghttp.Request){
        content, _ := gins.View().Parse("index.tpl", map[string]interface{}{
            "id"   : 123,
            "name" : "john",
        })
        r.Response.Write(content)
    })
}
```

>[danger] # 基本语法

模板引擎统一使用了 `{{` 和 `}}` 作为左右标签，没有其他的标签符号。

使用 `.` 来访问当前对象的值(模板全局变量)。

使用 `$` 来引用当前模板根级的上下文。

使用 `$var` 来访问特定的模板变量。


**模板中支持的 go 语言符号**

```
{{"string"}}     // 一般 string
{{`raw string`}} // 原始 string
{{'c'}}          // byte
{{print nil}}    // nil 也被支持
```

**模板中的 pipeline**

可以是上下文的变量输出，也可以是函数通过管道传递的返回值

```
{{. | FuncA | FuncB | FuncC}}
```

当 pipeline 的值等于:

* false 或 0
* nil 的指针或 interface
* 长度为 0 的 array, slice, map, string

那么这个 pipeline 被认为是空

>[success] ## if ... else ... end

```
{{if pipeline}}{{end}}
```

if 判断时，pipeline 为空时，相当于判断为 false


支持嵌套的循环

```
{{if .condition}}
{{else}}
	{{if .condition2}}{{end}}
{{end}}
```

也可以使用 else if 进行

```
{{if .condition}}
{{else if .condition2}}
{{else}}
{{end}}
```

>[success] ## range ... end

```
{{range pipeline}}{{.}}{{end}}
```

pipeline 支持的类型为 array, slice, map, channel

range 循环内部的 `.` 改变为以上类型的子元素

对应的值长度为 0 时，range 不会执行，`.` 不会改变

>[success] ## with ... end

```
{{with pipeline}}{{end}}
```

with 用于重定向 pipeline

```
{{with .Field.NestField.SubField}}
	{{.Var}}
{{end}}
```


>[success] ## define

define 可以用来定义自模板，可用于模块定义和模板嵌套

```
{{define "loop"}}
	<li>{{.Name}}</li>
{{end}}
```

使用 template 调用模板

```
<ul>
	{{range .Items}}
		{{template "loop" .}}
	{{end}}
</ul>
```

>[success] ## template

```
{{template "模板名" pipeline}}
```

将对应的上下文 pipeline 传给模板，才可以在模板中调用。


>[success] ## include

**该标签为gf模板引擎新增标签**

```
{{include "模板文件名(需要带完整文件名后缀)" pipeline}}
```

在模板中可以使用include标签载入其他模板，并且使用当前模板引擎已有的数据对于模板的分模块处理很有用处。模板文件名支持相对路径以及文件的系统绝对路径。如果想要把当前模板的模板变量传递给子模板(嵌套模板)，可以这样：
```
{{include "模板文件名" .}}
```

>[success] ## 注释

允许多行文本注释，不允许嵌套

```
{{/* 
comment content
support new line
*/}}
```

>[danger] # 基本函数

变量可以使用符号 `|` 在函数间传递

```
{{.value | Func1 | Func2}}
```

使用括号

```
{{printf "nums is %s %d" (printf "%d %d" 1 2) 3}}
```

>[success] ## and

```
{{and .X .Y .Z}}
```

and 会逐一判断每个参数，将返回第一个为空的参数，否则就返回最后一个非空参数

>[success] ## call

```
{{call .Field.Func .Arg1 .Arg2}}
```

call 可以调用函数，并传入参数

调用的函数需要返回 1 个值 或者 2 个值，返回两个值时，第二个值用于返回 error 类型的错误。返回的错误不等于 nil 时，执行将终止。

>[success] ## index

index 支持 map, slice, array, string，读取指定类型对应下标的值

```
{{index .Maps "name"}}
```

>[success] ## len

```
{{printf "The content length is %d" (.Content|len)}}
```

返回对应类型的长度，支持类型：map, slice, array, string, chan

>[success] ## not

not 返回输入参数的否定值，if true then false else true

>[success] ## or

```
{{or .X .Y .Z}}
```

or 会逐一判断每个参数，将返回第一个非空的参数，否则就返回最后一个参数

>[success] ## print

对应 fmt.Sprint

>[success] ## printf

对应 fmt.Sprintf

>[success] ## println

对应 fmt.Sprintln

>[success] ## urlquery

```
{{urlquery "http://johng.cn"}}
```

将返回

```
http%3A%2F%2Fjohng.cn
```

>[success] ## eq / ne / lt / le / gt / ge

这类函数一般配合在 if 中使用

```
`eq`: arg1 == arg2
`ne`: arg1 != arg2
`lt`: arg1 < arg2
`le`: arg1 <= arg2
`gt`: arg1 > arg2
`ge`: arg1 >= arg2
```

eq 和其他函数不一样的地方是，支持多个参数，和下面的逻辑判断相同

```
arg1==arg2 || arg1==arg3 || arg1==arg4 ...
```

与 if 一起使用

```
{{if eq true .Var1 .Var2 .Var3}}{{end}}
```

```
{{if lt 100 200}}{{end}}
```






