这种方式将每一个请求都当做一个控制器对象来处理，比较类似于PHP的控制器执行模式，当一个请求进来之后，立即初始化一个控制器对象进行处理，完成之后释放控制器资源。

以下是一个示例(gitee.com/johng/gf/geg/frame/mvc/controller/demo/user.go)：
```go
package demo
import (
    "gitee.com/johng/gf/g/net/ghttp"
    "gitee.com/johng/gf/g/frame/gmvc"
)

// 定义业务相关的控制器对象，
// 建议命名规范中控制器统一使用Controller前缀，后期代码维护时便于区分
type ControllerUser struct {
    gmvc.Controller
}

// 初始化控制器对象，并绑定操作到Web Server
func init() {
    // 绑定控制器到指定URI，所有控制器的公开方法将会映射到指定URI末尾
    // 例如该方法执行后，查看效果可访问：http://127.0.0.1:8199/user/name
    ghttp.GetServer().BindController("/user", &ControllerUser{})
}

// 定义操作逻辑 - 展示姓名
func (c *ControllerUser) Name() {
    c.Response.WriteString("John")
}
```
这种模式下的控制器struct必须继承于gmvc.Controller，该基类下提供多个与请求相关的资源对象支持(gitee.com/johng/gf/g/frame/gmvc/controller.go)：
```go
// 控制器基类
type Controller struct {
    Server   *ghttp.Server         // Web Server对象
    Request  *ghttp.ClientRequest  // 请求数据对象
    Response *ghttp.ServerResponse // 返回数据对象
    Cookie   *ghttp.Cookie         // COOKIE操作对象
    Session  *ghttp.Session        // SESSION操作对象
    View     *View                 // 视图对象
}
```
服务注册必须提供注册的URI，注册时ghttp会将所有控制器的公开方法将会映射到指定URI末尾，具体参见示例代码说明。

所有的服务注册统一在包的init初始化方法中完成，一个包可以包含多个文件，每个文件都可以有一个init初始化方法，可以分开注册，在使用的时候会通过同一个包引入进程序，自动调用初始化方法完成注册。

使用时的代码示例(gitee.com/johng/gf/geg/frame/mvc/main.go)：
```go
package main

import (
    "gitee.com/johng/gf/g/net/ghttp"
    _ "gitee.com/johng/gf/geg/frame/mvc/controller/demo"
)

func main() {
    ghttp.GetServer().SetPort(8199)
    ghttp.GetServer().Run()
}
```
其中通过：
```go
import _ "gitee.com/johng/gf/geg/frame/mvc/controller/demo"
```
便完成了包所有控制器的引入和注册。