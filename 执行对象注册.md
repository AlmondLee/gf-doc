
[TOC]


# 执行对象注册
控制器注册的设计模式相对来说比较简单，也易于管理，但是由于每一次请求都是新建一个控制器对象来处理，并且使用了反射机制，会有一定的性能损耗。

执行对象注册相对来说是一种比较高效的执行方式，但是运行机制、设计模式与控制器注册完全不同。执行对象注册与字面意思相同，就是在注册时便给定一个实例化的对象，以后每一个请求都交给该对象处理，该对象常驻内存不释放。由于相比较控制器注册来说，执行对象注册方式在处理请求的时候不需要不停地创建/销毁控制器对象，因此请求处理效率会高很多。

不过该对象需要自行负责对数据的并发安全以及关联资源维护，特别是对象本身的成员变量的维护。对于PHP转Go的开发者而言，控制器注册模式可能比较好理解，对执行对象注册可能会有点不习惯。

执行对象的定义没有严格要求，没有必要继承gmvc.Controller，因为在请求进入时没有自动初始化流程，内部的成员变量需要自行维护（包括变量初始化，变量销毁等）。

我们可以通过**ghttp.BindObject**方法完成执行对象的注册。
gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/object.go
```go
package demo

import "gitee.com/johng/gf/g/net/ghttp"

type Object struct {}

func init() {
    ghttp.GetServer().BindObject("/object", &Object{})
}

func (o *Object) Show(r *ghttp.Request) {
    r.Response.WriteString("It's show time bibi!")
}
```

注意公开方法的定义与控制器注册不同，必须为以下形式：

	func(r *ghttp.Request) 

否则无法完成注册，调用注册方法时会有错误提示，形如：

	panic: interface conversion: interface {} is func(), not func(*ghttp.Request)
    
通过 http://127.0.0.1:8199/object/show 查看效果。


# RESTful对象注册

和REST控制器注册类似，只不过注册的是一个实例化的对象。我们可以通过**ghttp.BindObjectRest**方法完成REST对象的注册。

gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/object_rest.go

```go
package demo

import "gitee.com/johng/gf/g/net/ghttp"

// 测试绑定对象
type ObjectRest struct {}

func init() {
    ghttp.GetServer().BindObjectRest("/object-rest", &ObjectRest{})
}

// RESTFul - GET
func (o *ObjectRest) Get(r *ghttp.Request) {
    r.Response.WriteString("RESTFul HTTP Method GET")
}

// RESTFul - POST
func (c *ObjectRest) Post(r *ghttp.Request) {
    r.Response.WriteString("RESTFul HTTP Method POST")
}

// RESTFul - DELETE
func (c *ObjectRest) Delete(r *ghttp.Request) {
    r.Response.WriteString("RESTFul HTTP Method DELETE")
}

// 该方法无法映射，将会无法访问到
func (c *ObjectRest) Hello(r *ghttp.Request) {
    r.Response.WriteString("Hello")
}
```
