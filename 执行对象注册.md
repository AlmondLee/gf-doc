控制器注册的设计模式相对来说比较简单，也易于管理，但是由于每一次请求都是新建一个控制器对象来处理，并且使用了反射机制，会有一定的性能损耗。

执行对象注册相对来说是一种比较高效的执行方式，但是运行机制、设计模式与控制器注册完全不同。对于PHP转Go的开发者而言，控制器注册模式可能比较好理解，对执行对象注册可能会有点不习惯。

执行对象注册与字面意思相同，就是在注册时便给定一个实例化的对象（指针），以后每一个请求都交给该对象处理，该对象常驻内存不释放。因此该对象需要自行负责对数据的并发安全以及数据安全维护，特别是对象本身的成员变量的维护。

执行对象的定义没有严格要求，没有必要继承gmvc.Controller，因为在请求进入时没有自动初始化流程，内部的成员变量需要自行维护。

我们可以通过**ghttp.BindObject**方法完成执行对象的注册。

以下是一个示例(gitee.com/johng/gf/geg/frame/mvc/controller/demo/test.go)：
```go
package demo

import "gitee.com/johng/gf/g/net/ghttp"

// 测试绑定对象
type T struct {}

// 初始化控制器对象，并绑定操作到Web Server
func init() {
    // 绑定对象，对象中的公开方法将会自动绑定到指定的URI末尾
    // ghttp.GetServer().BindObject("/test", &T{})
    // 只有localhost域名下才能访问该对象，
    // 对应URL为：http://localhost:8199/test/show
    // 通过该地址将无法访问到内容：http://127.0.0.1:8199/test/show
    ghttp.GetServer().Domain("localhost").BindObject("/test", &T{})
}

// 用于对象映射
func (t *T) Show(s *ghttp.Server, r *ghttp.ClientRequest, w *ghttp.ServerResponse) {
    w.WriteString("It's show time bibi!")
}

```

注意公开方法的定义与控制器注册不同，必须为以下形式：

	func(s *ghttp.Server, r *ghttp.ClientRequest, w *ghttp.ServerResponse) 

否则无法完成注册，调用注册方法时会有错误提示，形如：

	panic: interface conversion: interface {} is func(), not func(*ghttp.Server, *ghttp.ClientRequest, *ghttp.ServerResponse)
