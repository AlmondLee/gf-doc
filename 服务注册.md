用户访问某个URI时，Web Server能够精确的调用特定的服务模块提供服务，这些都是通过“服务注册”来实现的。

Web Server提供服务需要回调函数/方法/对象/控制器的支持，ghttp支持多种的服务注册方式，为开发者提供非常灵活的方式实现服务注册。

    func (s *Server) BindController(pattern string, c Controller) error
    func (s *Server) BindControllerMethod(pattern string, c Controller, method string) error
    func (s *Server) BindControllerRest(pattern string, c Controller) error
    
    func (s *Server) BindHandler(pattern string, handler HandlerFunc) error
    
    func (s *Server) BindObject(pattern string, obj interface{}) error
    func (s *Server) BindObjectRest(pattern string, obj interface{}) error

### 控制器注册
这种方式将每一个请求都当做一个控制器对象来处理，比较类似于PHP的控制器执行模式，当一个请求进来之后，立即初始化一个控制器对象进行处理，完成之后释放控制器资源。
以下是一个示例：

    import (
        "gitee.com/johng/gf/g/net/ghttp"
        "gitee.com/johng/gf/g/frame/gmvc"
    )

    // 定义业务相关的控制器对象，
    // 建议命名规范中控制器统一使用Controller前缀，后期代码维护时便于区分
    type ControllerUser struct {
        gmvc.Controller
    }

    // 初始化控制器对象，并绑定操作到Web Server
    func init() {
        // 绑定控制器到指定URI，所有控制器的公开方法将会映射到指定URI末尾
        // 例如该方法执行后，查看效果可访问：http://127.0.0.1:8199/user/info
        ghttp.GetServer().BindController("/user", &ControllerUser{})
    }

    // 定义操作逻辑 - 展示模板
    func (c *ControllerUser) Info() {
        c.View.Assign("name", "john")
        c.View.Display("user/index")
    }

这种模式下的控制器struct必须继承于gmvc.Controller，该基类下提供多个与请求相关的资源对象支持：

    // 控制器基类
    type Controller struct {
        Server   *ghttp.Server         // Web Server对象
        Request  *ghttp.ClientRequest  // 请求数据对象
        Response *ghttp.ServerResponse // 返回数据对象
        Cookie   *ghttp.Cookie         // COOKIE操作对象
        Session  *ghttp.Session        // SESSION操作对象
        View     *View                 // 视图对象
    }


### REST控制器



### 执行对象注册

### REST对象注册

### 回调函数注册



















