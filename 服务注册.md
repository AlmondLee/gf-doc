
[TOC]



当用户访问某个URI时，Web Server能够精确的调用特定的服务模块提供服务，这些都是通过“服务注册”来实现的。Web Server提供服务需要回调函数/方法/对象/控制器的支持，ghttp支持多种服务注册方式，为开发者提供非常强大和灵活的方式。服务注册是整个HTTP Server最核心的部分，也是gf框架中最精心设计的一个模块。本章节将会进行详细介绍。

>[danger] # 服务注册介绍

>>[success] ## 服务注册方法列表

    func (s *Server) BindController(pattern string, c Controller) error
    func (s *Server) BindControllerMethod(pattern string, c Controller, methods string) error
    func (s *Server) BindControllerRest(pattern string, c Controller) error
    func (s *Server) BindHandler(pattern string, handler HandlerFunc) error
    func (s *Server) BindObject(pattern string, obj interface{}) error
    func (s *Server) BindObjectRest(pattern string, obj interface{}) error

其中BindController*方法用于控制器相关注册，BindObject*方法用于对象相关注册，BindHandler方法用于特定的回调函数注册。

服务注册使用的pattern参数格式如下：

	[HTTP Method:]URI[@域名]

其中HTTP Method和域名为非必需参数，一般来说直接给定URI参数即可。因为需要使用HTTP Method注册的情况大多数为RESTful控制器，直接使用RESTful相关方法注册即可，域名支持也可以使用Domain方法来绑定。

此外BindController*系列方法第二个参数为控制器接口，给定的参数必须实现ghttp.Controller接口。方便的做法是自定义的控制器直接继承gmvc.Controller即可，gmvc.Controller已经实现对应的接口方法。


>>[success] ## 域名服务注册方法

服务注册支持绑定域名，以下是对应的方法列表：

    func (d *Domain) BindController(pattern string, c Controller) error
    func (d *Domain) BindControllerMethod(pattern string, c Controller, methods string) error
    func (d *Domain) BindControllerRest(pattern string, c Controller) error
    func (d *Domain) BindHandler(pattern string, handler HandlerFunc) error
    func (d *Domain) BindObject(pattern string, obj interface{}) error
    func (d *Domain) BindObjectRest(pattern string, obj interface{}) error
    
各项参数说明和Server的对应方法一致，只不过在Domain对象的底层会自动将方法绑定到Domain指定的域名列表中，只有对应的域名才能提供访问。

>>[success] ## 服务注册初始化

所有的服务注册统一在包的init初始化方法中完成，一个包可以包含多个文件，每个文件都可以有一个init初始化方法，可以分开注册，在使用的时候会通过同一个包引入进程序，自动调用初始化方法完成注册。

来看一个例子：
gitee.com/johng/gf/blob/master/geg/frame/mvc/main.go
```go
package main

import (
    "gitee.com/johng/gf/g/net/ghttp"
    _ "gitee.com/johng/gf/geg/frame/mvc/controller/demo"
)

func main() {
    ghttp.GetServer().SetPort(8199)
    ghttp.GetServer().Run()
}
```
其中通过：
```go
import _ "gitee.com/johng/gf/geg/frame/mvc/controller/demo"
```
便完成了对包中的所有控制器的引入和注册（当然，包中的init应当实现注册方法调用），demo包具体的控制器注册以及相关逻辑我们将在下一章节继续介绍。







>[danger] # 控制器注册

>>[success] ## 控制器注册
这种方式将每一个请求都当做一个控制器对象来处理，比较类似于PHP的请求执行模式，当一个请求进来之后，立即初始化一个控制器对象进行处理，完成之后释放控制器资源。

我们可以通过**ghttp.BindController**方法完成控制器的注册。

gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/user.go
```go
package demo

import (
    "gitee.com/johng/gf/g/net/ghttp"
    "gitee.com/johng/gf/g/frame/gmvc"
)

// 定义业务相关的控制器对象，
// 建议命名规范中控制器统一使用Controller前缀，后期代码维护时便于区分
type ControllerUser struct {
    gmvc.Controller
}

// 初始化控制器对象，并绑定操作到Web Server
func init() {
    // 绑定控制器到指定URI，所有控制器的公开方法将会映射到指定URI末尾
    // 例如该方法执行后，查看效果可访问：
    // http://127.0.0.1:8199/user/name
    // http://127.0.0.1:8199/user/age
    ghttp.GetServer().BindController("/user", &ControllerUser{})
}

// 定义操作逻辑 - 展示姓名
func (c *ControllerUser) Name() {
    c.Response.WriteString("John")
}

// 定义操作逻辑 - 展示年龄
func (c *ControllerUser) Age() {
    c.Response.WriteString("18")
}
```

服务注册必须提供注册的URI，注册时ghttp会将所有控制器的公开方法将会映射到指定URI末尾，具体参见示例代码说明。注册的控制器参数是一个ghttp.Controller接口，参数直接传递自定义的控制器对象指针即可(&ControllerUser{})。ghttp通过解析该对象指针获取对应的控制器方法，生成反射类型，处理请求时再根据该反射类型生成对应的控制器对象，处理请求。

>>[success] ## 控制器方法注册

假如控制器中有若干公开方法，但是我只想注册其中几个，其余的方法我不想对外公开，怎么办？

实际开发中难免会遇到这种比较特殊的场景，当然ghttp也是支持这种需求。我们可以通过**ghttp.BindControllerMethod**方法完成对控制器指定方法的注册。相对于ghttp.BindController注册方法，ghttp.BindControllerMetho多了一个方法名称参数methods，参数支持传入多个方法名称，多个名称以英文“,”号分隔。

看下面这个例子，执行后ControllerMethod的Name和Age方法将被注册到Web Server提供服务，而Info方法却不会对外公开。
gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/method.go
```go
package demo

import (
    "gitee.com/johng/gf/g/net/ghttp"
    "gitee.com/johng/gf/g/frame/gmvc"
)

type ControllerMethod struct {
    gmvc.Controller
}

func init() {
    ghttp.GetServer().BindControllerMethod("/method", &ControllerMethod{}, "Name, Age")
}

func (c *ControllerMethod) Name() {
    c.Response.WriteString("John")
}

func (c *ControllerMethod) Age() {
    c.Response.WriteString("18")
}

func (c *ControllerMethod) Info() {
    c.Response.WriteString("Info")
}
```

>>[success] ## RESTful控制器注册

RESTful设计方式的控制器，通常用于API服务。在这种模式下，HTTP的Method将会映射到控制器对应的方法，例如：POST方式将会映射到控制器的Post方法中，DELETE方式将会映射到控制器的Delete方法中。其他非HTTP Method命名的方法，即使是定义的包公开方法，将无法完成自动注册，对于应用端不可见。当然，如果控制器并未定义对应HTTP Method的方法，该Method请求下将会返回 HTTP Status 404。此外，控制器方法只要保证是与HTTP Method相同的公开方法即可(方法名首字母大写)，命名未有其他特定要求。

这种方式注册的控制器，运行模式和“控制器注册”模式相同。我们可以通过**ghttp.BindControllerRest**方法完成RESTful控制器的注册。

以下是一个示例：
gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/rest.go
```go
package demo

import (
    "gitee.com/johng/gf/g/net/ghttp"
    "gitee.com/johng/gf/g/frame/gmvc"
)

// 测试控制器
type ControllerRest struct {
    gmvc.Controller
}

// 初始化控制器对象，并绑定操作到Web Server
func init() {
    // 控制器公开方法中与HTTP Method方法同名的方法将会自动绑定映射
    ghttp.GetServer().BindControllerRest("/user", &ControllerRest{})
}

// RESTFul - GET
func (c *ControllerUser) Get() {
    c.Response.WriteString("RESTFul HTTP Method GET")
}

// RESTFul - POST
func (c *ControllerUser) Post() {
    c.Response.WriteString("RESTFul HTTP Method POST")
}

// RESTFul - DELETE
func (c *ControllerUser) Delete() {
    c.Response.WriteString("RESTFul HTTP Method DELETE")
}

// 该方法无法映射，将会无法访问到
func (c *ControllerUser) Hello() {
    c.Response.WriteString("Hello")
}
```

>>[success] ## Init与Shut回调方法

ghttpController接口中的Init和Shut是两个在HTTP请求流程中被Web Server自动调用的方法。gmvc.Controller已经实现了这两个方法，用户自定义的控制器类直接继承gmvc.Controller即可。如果需要自定义请求初始化一级请求结束时的一些业务逻辑操作，可以在自定义控制器中重载这两个方法。

>>>[info] ### ghttp.Controller接口

```go
type Controller interface {
    Init(*Request)
    Shut()
}
```
>>>[info] ### gmvc.Controller基类

```go
type Controller struct {
    Request  *ghttp.Request  // 请求数据对象
    Response *ghttp.Response // 返回数据对象(r.Response)
    Server   *ghttp.Server   // Web Server对象(r.Server)
    Cookie   *ghttp.Cookie   // COOKIE操作对象
    Session  *ghttp.Session  // SESSION操作对象
    View     *View           // 视图对象
}
```

>>>[info] ### Init

控制器初始化方法，参数是当前请求的对象。gmvc.Controller基类中的Init方法是对自身成员对象的初始化。

>>>[info] ### Shut

当请求结束时被Web Server自动调用，可以用于控制器一些收尾处理的操作。






















>[danger]# 执行对象注册

>>[success]## 执行对象注册

控制器注册的设计模式相对来说比较简单，也易于管理，但是由于每一次请求都是新建一个控制器对象来处理，并且使用了反射机制，会有一定的性能损耗。

执行对象注册相对来说是一种比较高效的执行方式，但是运行机制、设计模式与控制器注册完全不同。执行对象注册与字面意思相同，就是在注册时便给定一个实例化的对象，以后每一个请求都交给该对象处理，该对象常驻内存不释放。由于相比较控制器注册来说，执行对象注册方式在处理请求的时候不需要不停地创建/销毁控制器对象，因此请求处理效率会高很多。

不过该对象需要自行负责对数据的并发安全以及关联资源维护，特别是对象本身的成员变量的维护。对于PHP转Go的开发者而言，控制器注册模式可能比较好理解，对执行对象注册可能会有点不习惯。

执行对象的定义没有严格要求，没有必要继承gmvc.Controller，因为在请求进入时没有自动初始化流程，内部的成员变量需要自行维护（包括变量初始化，变量销毁等）。

我们可以通过**ghttp.BindObject**方法完成执行对象的注册。
gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/object.go
```go
package demo

import "gitee.com/johng/gf/g/net/ghttp"

type Object struct {}

func init() {
    ghttp.GetServer().BindObject("/object", &Object{})
}

func (o *Object) Show(r *ghttp.Request) {
    r.Response.WriteString("It's show time bibi!")
}
```

注意公开方法的定义与控制器注册不同，必须为以下形式：

	func(r *ghttp.Request) 

否则无法完成注册，调用注册方法时会有错误提示，形如：

	panic: interface conversion: interface {} is func(), not func(*ghttp.Request)
    
通过 http://127.0.0.1:8199/object/show 查看效果。


>>[success]## RESTful对象注册

和REST控制器注册类似，只不过注册的是一个实例化的对象。我们可以通过**ghttp.BindObjectRest**方法完成REST对象的注册。

gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/object_rest.go

```go
package demo

import "gitee.com/johng/gf/g/net/ghttp"

// 测试绑定对象
type ObjectRest struct {}

func init() {
    ghttp.GetServer().BindObjectRest("/object-rest", &ObjectRest{})
}

// RESTFul - GET
func (o *ObjectRest) Get(r *ghttp.Request) {
    r.Response.WriteString("RESTFul HTTP Method GET")
}

// RESTFul - POST
func (c *ObjectRest) Post(r *ghttp.Request) {
    r.Response.WriteString("RESTFul HTTP Method POST")
}

// RESTFul - DELETE
func (c *ObjectRest) Delete(r *ghttp.Request) {
    r.Response.WriteString("RESTFul HTTP Method DELETE")
}

// 该方法无法映射，将会无法访问到
func (c *ObjectRest) Hello(r *ghttp.Request) {
    r.Response.WriteString("Hello")
}
```







>[danger]# 回调函数注册

这种方式的运行机制类似于执行对象注册，不过注册的是一个函数。相比较于执行对象注册，注册时不会有额外的对象实例化开销，注册时只是保存了一个函数的指针地址。

我们可以通过**ghttp.BindHandler**方法完成回调函数的注册。

gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/apple_pen.go
```go
package demo

import "gitee.com/johng/gf/g/net/ghttp"

func init() {
    ghttp.GetServer().BindHandler("/apple",     Apple)
    ghttp.GetServer().BindHandler("/pen",       Pen)
    ghttp.GetServer().BindHandler("/apple-pen", ApplePen)
}

func Apple(r *ghttp.Request) {
    r.Response.WriteString("Apple")
}

func Pen(r *ghttp.Request) {
    r.Response.WriteString("Pen")
}

func ApplePen(r *ghttp.Request) {
    r.Response.WriteString("Apple-Pen")
}
```

So easy!



			









