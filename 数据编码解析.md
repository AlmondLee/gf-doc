



>[danger] # gparser

gf框架针对常用的数据格式编码解析，提供了异常强大灵活的功能，由gparser包提供，支持Go变量(interface{})、JSON、XML、YAML/YML、TOML数据格式之间的相互转换，支持按照层级进行数据检索访问、支持运行时动态修改/新增/删除层级变量(并发安全)等特性。

>[success] ## 方法列表

```go
func VarToJson(value interface{}) ([]byte, error)
func VarToJsonIndent(value interface{}) ([]byte, error)
func VarToToml(value interface{}) ([]byte, error)
func VarToXml(value interface{}, rootTag ...string) ([]byte, error)
func VarToXmlIndent(value interface{}, rootTag ...string) ([]byte, error)
func VarToYaml(value interface{}) ([]byte, error)
type Parser
    func Load(path string) (*Parser, error)
    func LoadContent(data []byte, fileType string) (*Parser, error)
    func New(values...interface{}) *Parser
    func (p *Parser) Get(pattern string) interface{}
    func (p *Parser) GetArray(pattern string) []interface{}
    func (p *Parser) GetBool(pattern string) bool
    func (p *Parser) GetFloat32(pattern string) float32
    func (p *Parser) GetFloat64(pattern string) float64
    func (p *Parser) GetInt(pattern string) int
    func (p *Parser) GetMap(pattern string) map[string]interface{}
    func (p *Parser) GetString(pattern string) string
    func (p *Parser) GetToVar(pattern string, v interface{}) error
    func (p *Parser) GetUint(pattern string) uint
    func (p *Parser) Set(pattern string, value interface{}) error
    func (p *Parser) ToArray() []interface{}
    func (p *Parser) ToJson() ([]byte, error)
    func (p *Parser) ToJsonIndent() ([]byte, error)
    func (p *Parser) ToMap() map[string]interface{}
    func (p *Parser) ToToml() ([]byte, error)
    func (p *Parser) ToXml(rootTag ...string) ([]byte, error)
    func (p *Parser) ToXmlIndent(rootTag ...string) ([]byte, error)
    func (p *Parser) ToYaml() ([]byte, error)
```
以上方法简要说明，
1. Load与LoadContent方法支持根据文件及内容，生成gparser.Parser对象；
2. New方法支持生成一个空的gparser.Parser对象，常用用于动态数据生成；
3. Get\*相关方法支持按照层级检索数据，pattern参数中使用英文"."号区分层级关系；
4. Set方法支持按照层级修改/新增/删除变量，变量类型支持任意类型；
5. To\*相关方法支持将gparser.Parser对象生成为支持的数据格式字符串；
6. VarTo\*相关方法支持将任意的Go变量转换为支持的数据格式字符串；


>[success] ## 使用示例

1. **数据层级检索**
	示例1，读取JSON：
    ```go
    data :=
        `{
            "users" : {
                    "count" : 100,
                    "list"  : [
                        {"name" : "Ming", "score" : 60},
                        {"name" : "John", "score" : 99.5}
                    ]
            }
        }`

    if p, e := gparser.LoadContent([]byte(data), "json"); e != nil {
        glog.Error(e)
    } else {
        fmt.Println("John Score:", p.GetFloat32("users.list.1.score"))
    }
    ```
	示例2，读取XML：
    ```go
    data :=
        `<?xml version="1.0" encoding="UTF-8"?>
         <note>
           <to>Tove</to>
           <from>Jani</from>
           <heading>Reminder</heading>
           <body>Don't forget me this weekend!</body>
         </note>`

    if p, e := gparser.LoadContent([]byte(data), "xml"); e != nil {
        glog.Error(e)
    } else {
        fmt.Println("Heading:", p.GetString("note.heading"))
    }
    ```
    
2. **处理键名本身带有层级符号"."的情况**

    ```go
    data :=
        `{
            "users" : {
                "count" : 100
            },
            "users.count" : 101
        }`
    if p, e := gparser.LoadContent([]byte(data), "json"); e != nil {
        glog.Error(e)
    } else {
        fmt.Println("Users Count:", p.Get("users.count"))
    }
    ```
    运行之后打印出的结果为```101```。当键名存在"."号时，检索优先级：键名->层级，因此并不会引起歧义。
    
1. **支持运行时数据修改**

    ```go
    data :=
        `{
            "users" : {
                "count" : 100
            }
        }`
    if p, e := gparser.LoadContent([]byte(data), "json"); e != nil {
        glog.Error(e)
    } else {
        p.Set("users.count",  1)
        p.Set("users.list",  []string{"John", "小明"})
        c, _ := p.ToJson()
        fmt.Println(string(c))
    }
    ```
    执行后输出结果为：
    ```{"users":{"count":1,"list":["John","小明"]}}```
	gparser包的数据运行时修改特性非常强大，在该特性的支持下，各种数据结构的编码/解析显得异常的灵活方便。
    
1. **运行时动态删除变量**
    我们再来看一个删除变量的例子：
    ```go
    data :=
        `<?xml version="1.0" encoding="UTF-8"?>
         <article>
           <count>10</count>
           <list><title>gf article1</title><content>gf content1</content></list>
           <list><title>gf article2</title><content>gf content2</content></list>
           <list><title>gf article3</title><content>gf content3</content></list>
         </article>`
    if p, e := gparser.LoadContent([]byte(data), "xml"); e != nil {
        glog.Error(e)
    } else {
        p.Set("article.list.0", nil)
        c, _ := p.ToJson()
        fmt.Println(string(c))
    }
    ```
	以上程序输出结果为：
    ```json
	{"article":{"count":"10","list":[{"content":"gf content2","title":"gf article2"},{"content":"gf content3","title":"gf article3"}]}}
    ```
    可以看到，当需要删除内容时，设定对应层级的值为nil即可。在该示例中，我们删除了article.list数组的索引0数据项，并将XML转换为JSON数据格式返回。
    
1. **动态生成数据格式**
	我们来动态生成一个XML，先来一个简单一点的。
    ```go
    p := gparser.New()
    p.Set("name",   "john")
    p.Set("age",    18)
    p.Set("scores", map[string]int{
        "语文" : 100,
        "数学" : 100,
        "英语" : 100,
    })
    c, _ := p.ToXmlIndent("simple-xml")
    fmt.Println(string(c))
    ```
    执行后，输出结果为：
    ```xml
    <simple-xml>
        <age>18</age>
        <name>john</name>
        <scores>
            <数学>100</数学>
            <英语>100</英语>
            <语文>100</语文>
        </scores>
    </simple-xml>
    ```
	可以看到，我们直接使用Set方式便创建了一个XML数据格式，根本就不需要struct有木有？！想要struct？当然也可以，那我们再来一个稍微复杂一点的例子，里面包含了层级新增变量以及struct数据变量：
    ```go
    type Order struct {
        Id    int      `json:"id"`
        Price float32  `json:"price"`
    }
    p := gparser.New()
    p.Set("orders.list.0", Order{1, 100})
    p.Set("orders.list.1", Order{2, 666.66})
    p.Set("orders.list.2", Order{3, 999.99})
    fmt.Println("Order 1 Price:", p.Get("orders.list.1.price"))
    c, _ := p.ToJson()
    fmt.Println(string(c))
    // {"orders":{"list":{"0":{"id":1,"price":100},"1":{"id":2,"price":666.66},"2":{"id":3,"price":999.99}}}}
    ```
    执行后，输出结果为：
    ```shell
    Order 1 Price: 666.66
    {"orders":{"list":{"0":{"id":1,"price":100},"1":{"id":2,"price":666.66},"2":{"id":3,"price":999.99}}}}
    ```
    怎么样，有没有觉得很6？
    

3. **数据格式相互转换**
	来个数据结构简单点的：
    ```go
    p := gparser.New(map[string]string{
        "name" : "gf",
        "site" : "https://gitee.com/johng",
    })
    c, _ := p.ToJson()
    fmt.Println("JSON:")
    fmt.Println(string(c))
    fmt.Println("======================")

    fmt.Println("XML:")
    c, _ = p.ToXmlIndent()
    fmt.Println(string(c))
    fmt.Println("======================")

    fmt.Println("YAML:")
    c, _ = p.ToYaml()
    fmt.Println(string(c))
    fmt.Println("======================")

    fmt.Println("TOML:")
    c, _ = p.ToToml()
    fmt.Println(string(c))
    ```
    执行后，输出结果为：
    ```shell
    JSON:
    {"name":"gf","site":"https://gitee.com/johng"}
    ======================
    XML:
    <doc/>
    ======================
    YAML:
    name: gf
    site: https://gitee.com/johng

    ======================
    TOML:
    name = "gf"
    site = "https://gitee.com/johng"
    ```
    
    
    
    