



>[danger] # gparser

gf框架提供了异常强大灵活的针对常用数据格式编码解析功能，由gparser包提供，支持Go变量(interface{})、JSON、XML、YAML/YML、TOML数据格式之间的相互转换，支持按照层级进行数据检索访问、支持运行时动态修改层级变量(并发安全)等特性。

>[success] ## 方法列表

```go
func VarToJson(value interface{}) ([]byte, error)
func VarToJsonIndent(value interface{}) ([]byte, error)
func VarToToml(value interface{}) ([]byte, error)
func VarToXml(value interface{}, rootTag ...string) ([]byte, error)
func VarToXmlIndent(value interface{}, rootTag ...string) ([]byte, error)
func VarToYaml(value interface{}) ([]byte, error)
type Parser
    func Load(path string) (*Parser, error)
    func LoadContent(data []byte, fileType string) (*Parser, error)
    func New() *Parser
    func (p *Parser) Get(pattern string) interface{}
    func (p *Parser) GetArray(pattern string) []interface{}
    func (p *Parser) GetBool(pattern string) bool
    func (p *Parser) GetFloat32(pattern string) float32
    func (p *Parser) GetFloat64(pattern string) float64
    func (p *Parser) GetInt(pattern string) int
    func (p *Parser) GetMap(pattern string) map[string]interface{}
    func (p *Parser) GetString(pattern string) string
    func (p *Parser) GetToVar(pattern string, v interface{}) error
    func (p *Parser) GetUint(pattern string) uint
    func (p *Parser) Set(pattern string, value interface{}) error
    func (p *Parser) ToArray() []interface{}
    func (p *Parser) ToJson() ([]byte, error)
    func (p *Parser) ToJsonIndent() ([]byte, error)
    func (p *Parser) ToMap() map[string]interface{}
    func (p *Parser) ToToml() ([]byte, error)
    func (p *Parser) ToXml(rootTag ...string) ([]byte, error)
    func (p *Parser) ToXmlIndent(rootTag ...string) ([]byte, error)
    func (p *Parser) ToYaml() ([]byte, error)
```
以上方法简要说明，
1. Load与LoadContent方法支持根据文件及内容，生成gparser.Parser对象；
2. New方法支持生成一个空的gparser.Parser对象，常用用于动态数据生成；
3. Get\*相关方法支持按照层级检索数据，pattern参数中使用英文"."号区分层级关系；
4. Set方法支持按照层级修改/新增/删除变量，变量类型支持任意类型；
5. To\*相关方法支持将gparser.Parser对象生成为支持的数据格式字符串；
6. VarTo\*相关方法支持将任意的Go变量转换为支持的数据格式字符串；


>[success] ## 使用示例

1. **数据层级检索**

    ```go
    data :=
        `{
            "users" : {
                    "count" : 100,
                    "list"  : [
                        {"name" : "Ming", "score" : 60},
                        {"name" : "John", "score" : 99.5}
                    ]
            }
        }`

    if p, e := gparser.LoadContent([]byte(data), "json"); e != nil {
        glog.Error(e)
    } else {
        fmt.Println("John Score:", p.GetFloat32("users.list.1.score"))
    }
    ```

    ```go
    data :=
        `<?xml version="1.0" encoding="UTF-8"?>
         <note>
           <to>Tove</to>
           <from>Jani</from>
           <heading>Reminder</heading>
           <body>Don't forget me this weekend!</body>
         </note>`

    if p, e := gparser.LoadContent([]byte(data), "xml"); e != nil {
        glog.Error(e)
    } else {
        fmt.Println("Heading:", p.GetString("note.heading"))
    }
    ```
    
2. **处理键名本身带有层级符号"."的情况**

    ```go
    data :=
        `{
            "users" : {
                "count" : 100
            },
            "users.count" : 101
        }`
    if p, e := gparser.LoadContent([]byte(data), "json"); e != nil {
        glog.Error(e)
    } else {
        fmt.Println("Users Count:", p.Get("users.count"))
    }
    ```
    运行之后打印出的结果为```101```。当键名存在"."号时，检索优先级：键名->层级，因此并不会引起歧义。
    
1. **支持运行时数据修改**

    ```go
    data :=
        `{
            "users" : {
                "count" : 100
            }
        }`
    if p, e := gparser.LoadContent([]byte(data), "json"); e != nil {
        glog.Error(e)
    } else {
        p.Set("users.count",  1)
        p.Set("users.list",  []string{"John", "小明"})
        c, _ := p.ToJson()
        fmt.Println(string(c))
    }
    ```
    执行后输出结果为：
    ```{"users":{"count":1,"list":["John","小明"]}}```
	gparser包的数据运行时修改特性非常强大，在该特性的支持下，各种数据结构的编码/解析显得异常的灵活方便。
    
1. **运行时动态删除变量**
    我们再来看一个删除变量的例子：
    ```go
    data :=
        `<?xml version="1.0" encoding="UTF-8"?>
         <article>
           <count>10</count>
           <list><title>gf article1</title><content>gf content1</content></list>
           <list><title>gf article2</title><content>gf content2</content></list>
           <list><title>gf article3</title><content>gf content3</content></list>
         </article>`
    if p, e := gparser.LoadContent([]byte(data), "xml"); e != nil {
        glog.Error(e)
    } else {
        p.Set("article.list.0", nil)
        c, _ := p.ToJson()
        fmt.Println(string(c))
    }
    ```
	以上程序输出结果为：
    ```json
	{"article":{"count":"10","list":[{"content":"gf content2","title":"gf article2"},{"content":"gf content3","title":"gf article3"}]}}
    ```
    可以看到，当需要删除内容时，设定对应层级的值为nil即可。在该示例中，我们删除了article.list数组的索引0数据项，并将XML转换为JSON数据格式返回。
    
3. **数据格式相互转换**

    ```go
    data :=
        `{
            "users" : {
                "count" : 100,
                "list"  : ["John", "小明"]
            }
        }`
    j, err := gjson.DecodeToJson([]byte(data))
    if err != nil {
        glog.Error(err)
    } else {
        c, _ := j.ToJson()
        fmt.Println("JSON:")
        fmt.Println(string(c))
        fmt.Println("======================")

        fmt.Println("XML:")
        c, _ = j.ToXmlIndent()
        fmt.Println(string(c))
        fmt.Println("======================")

        fmt.Println("YAML:")
        c, _ = j.ToYaml()
        fmt.Println(string(c))
        fmt.Println("======================")

        fmt.Println("TOML:")
        c, _ = j.ToToml()
        fmt.Println(string(c))
    }
    ```
    gjson支持将JSON转换为其他的数据格式，目前支持：JSON、XML、YAML/YML、TOML数据格式之间的相互转换。
    
    
    
    