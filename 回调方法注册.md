>[danger] # 回调函数注册

**回调函数+执行对象混合注册是推荐的服务注册方式。**

这种方式的运行机制类似于执行对象注册，不过注册的是一个函数/方法。相比较于执行对象注册，注册时不会有额外的对象实例化开销，注册时只是保存了一个函数/方法的指针地址。这种方式的服务注册比较灵活，注册的服务可以是一个实例化对象的方法地址，也可以是一个包方法地址。服务需要的数据可以通过包内部变量形式或者对象内部变量形式进行管理，开发者可根据实际情况进行灵活控制。

我们可以通过```ghttp.BindHandler```方法完成回调函数的注册，在gf框架的开发手册中很多地方都使用了回调函数注册的方式来做演示，因为这种注册方式比较简单。

## 使用示例1，基本使用
gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/apple_pen.go

```go
package demo

import (
    "gitee.com/johng/gf/g/net/ghttp"
    "gitee.com/johng/gf/g"
)

func init() {
    s := g.Server()
    s.BindHandler("/apple",     Apple)
    s.BindHandler("/pen",       Pen)
    s.BindHandler("/apple-pen", ApplePen)
}

func Apple(r *ghttp.Request) {
    r.Response.Write("Apple")
}

func Pen(r *ghttp.Request) {
    r.Response.Write("Pen")
}

func ApplePen(r *ghttp.Request) {
    r.Response.Write("Apple-Pen")
}
```

## 使用示例2，与执行对象混合使用
gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/product.go
```go
package demo

import (
    "gitee.com/johng/gf/g"
    "gitee.com/johng/gf/g/net/ghttp"
    "gitee.com/johng/gf/g/util/gconv"
)

type Product struct {
    total int
}

func init() {
    p := &Product{}
    g.Server().BindHandler("/product/total", p.Total)
    g.Server().BindHandler("/product/list/{page}.html", p.List)
}

func (p *Product) Total(r *ghttp.Request) {
    p.total++
    r.Response.Write("total: ", gconv.String(p.total))
}

func (p *Product) List(r *ghttp.Request) {
    r.Response.Write("page: ", r.Get("page"))
}
```
在这个示例中，我们使用对象来封装业务逻辑和所需的变量，使用回调函数注册来灵活注册对应的对象方法。

## 使用示例3，使用包变量管理内部变量
gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/stats/stats.go
```go
package stats

import (
    "gitee.com/johng/gf/g"
    "gitee.com/johng/gf/g/net/ghttp"
)

var (
    total int
)

func init() {
    g.Server().BindHandler("/stats/total", showTotal)
}

func showTotal(r *ghttp.Request) {
    total++
    r.Response.Write("total:", total)
}

```










