
[TOC]

>[danger] # 使用方法

>[success] ## 控制器视图

gf为控制器提供了良好的模板引擎支持，由gmvc.View视图对象进行管理，提供了良好的数据隔离性。控制器视图是并发安全设计的，允许在多线程中异步操作。
```go
func (view *View) Assign(key string, value interface{})
func (view *View) Assigns(data map[string]interface{})
func (view *View) Display(files ...string) error
func (view *View) Parse(file string) ([]byte, error)
func (view *View) ParseContent(name string, content string) ([]byte, error)
```
使用示例：

gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/template.go

```go
package demo

import (
    "gitee.com/johng/gf/g/net/ghttp"
    "gitee.com/johng/gf/g/frame/gmvc"
)

type ControllerTemplate struct {
    gmvc.Controller
}

func init() {
    ghttp.GetServer().BindControllerMethod("/template", &ControllerTemplate{}, "Info")
}

func (c *ControllerTemplate) Info() {
    c.View.Assign("name", "john")
    c.View.Assigns(map[string]interface{}{
        "age"   : 18,
        "score" : 100,
    })
    c.View.Display("user/index.tpl")
}
```
其中，给定的模板文件file参数是需要带完整的文件名后缀，例如：index.tpl，index.html等等，模板引擎对模板文件后缀名没有要求，用户可完全自定义。此外，模板文件参数也支持文件的绝对路径(完整的文件路径)。

>[success] ## 非控制器视图

非控制器中使用模板引擎没有控制器视图的支持，可以使用底层的gview包来实现，可以通过单例管理器来获取默认的单例gview对象。

gview包方法列表：
```go
func Get(path string) *View
func New(path string) *View
func (view *View) BindFunc(name string, function interface{})
func (view *View) Parse(file string, params map[string]interface{}) ([]byte, error)
func (view *View) ParseContent(name string, content string, params map[string]interface{}) ([]byte, error)

func (view *View) GetPath() string
func (view *View) SetPath(path string)
```
使用示例：

gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/template2.go

```go
package demo

import (
    "gitee.com/johng/gf/g/net/ghttp"
    "gitee.com/johng/gf/g/frame/gins"
)

func init() {
    ghttp.GetServer().BindHandler("/template2", func(r *ghttp.Request){
        content, _ := gins.View().Parse("index.tpl", map[string]interface{}{
            "id"   : 123,
            "name" : "john",
        })
        r.Response.Write(content)
    })
}
```
在这个示例中我们使用单例管理器获取一个默认的视图对象，随后通过该视图渲染对应模板目录下的index.tpl模板文件并给定模板变量参数。

我们也可以通过SetPath方法中心指定视图对象的模板目录，该方法是并发安全的，但是需要注意一旦改变了该视图对象的模板目录，将会在整个进程中生效。

使用示例：

gitee.com/johng/gf/blob/master/geg/frame/mvc/controller/demo/template3.go

```go
package demo

import (
    "gitee.com/johng/gf/g/net/ghttp"
    "gitee.com/johng/gf/g/frame/gins"
)

func init() {
    gins.View().SetPath("/home/www/template/")
    ghttp.GetServer().BindHandler("/template3", func(r *ghttp.Request){
        content, _ := gins.View().Parse("index.tpl", map[string]interface{}{
            "id"   : 123,
            "name" : "john",
        })
        r.Response.Write(content)
    })
}
```

>[success] ## 修改模板目录

模板引擎作为gf框架的核心组件，可以通过以下方式修改模板引擎的默认模板文件查找目录：
1. (推荐)单例模式获取全局View对象，通过```SetPath```方法手动修改
2. 修改命令行启动参数 - ```viewpath```
3. 修改指定的环境变量 - ```gf.viewpath```

例如，我们的执行程序文件为main，那么可以通过以下方式修改模板引擎的模板目录(Linux下)：

1. (推荐)通过单例模式
	```go
    gins.View().SetPath("/opt/template")
    ```
3. 通过命令行参数
    ```shell
    ./main --viewpath=/opt/template/
    ```
1. 通过环境变量
    * 启动时修改环境变量：
        ```shell
        gf.viewpath=/opt/config/; ./main
        ```
    * 使用genv包来修改环境变量：
        ```go
        genv.Set("gf.viewpath", "/opt/template")
        ```


